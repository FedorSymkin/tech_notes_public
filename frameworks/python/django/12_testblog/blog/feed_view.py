"""
Генерация ленты вынесена в отдельный файл. Тут наиболее интересен не столько код,
сколько комментарии вокруг него.
"""


from rest_framework import generics
from django.db.models import F
from rest_framework.permissions import IsAuthenticated

from . import models
from . import serializers


class FeedView(generics.ListAPIView):
    """
    Generate posts feed of current authenticated user.
    Feed is generated by following rules: <br>
        * Get posts of users current user subscribed to <br>
        * Posts are newer than subscribe time <br>
        * Exclude posts marked as read <br>
        * Posts are sorted by datetime (newer first) <br>
    """
    serializer_class = serializers.PostSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        """
            Несколько слов о запросе и процессе моего более подробного знакомства с Django ORM.

            * Задача:
                * Есть заданный пользователь.
                * Нужно получить посты всех пользователей, на которых он подписан
                * Брать только посты свежее чем время подписки
                * Исключать прочитанные посты
                * Сортировать по времени

            * Про знакомство с Django ORM:
                * С самим Django я знакомился целенаправленно,
                    по видео tutorial-у, внимательно проходя по всем принципиальным моментам

                * На такое же аккуратное знакомство с Django ORM времени пока не хватило, поэтому
                    исходил из цели решить текущую задачу, набирая нужную информацию гуглёжкой
                     документации и разных статей.

                * Общие впечатления: наверное если поработать какое-то время с Django ORM можно привыкнуть,
                    но по самому первому впечатлению Django ORM мне показался слишком перемудрённым
                    и слишком декларативным - вещи которые довольно просто сделать сырым SQL,
                    на Django ORM делаются путём неинтуитивной настройки
                    всяких разных декларативных штук, и я вижу в этом такие проблемы:

                        * Довольно долго копаться и разбираться, во всяком случае если не работал раньше с этим
                        * Для более сложных запросов неочевидно, что происходит на SQL, надо всегда проверять
                            (может там 100500 запросов по каждому элементу?)
                        * Делается несколько SQL запросов для того, что можно сделать одним запросом
                        * Могут генерироваться неоптимальные запросы


            Не факт что запрос оптимален. Может быть можно лучше.
            Чтобы сделать оптимальнее, нужно более плотно познакомиться с Django ORM.


            * Как устроен запрос:
                * Джойним посты и подписки, берём только подписки нашего пользователя:
                    Это prefetch_related и фильтр по from_id

                * Для каждой записи Post у нас теперь есть datetime оформления подписки нашего пользователя.
                    Фильтруем, сравнивая datetime подписки и datetime поста

                * Фильтруем по прочитанным постам нашего пользователя

            Нюансы и неочевидности:
                * Если сделать 2 раза filter по каждому условию - будет почему-то 2 раза join в SQL.
                    Почему - ещё не разбирался.
                * В prefetch_related можно было бы поставить Prefetch c фильтрованным queryset внутри,
                    но так почему-то не работает. Просто нет фильтрации. Почему - ещё не разбирался.
        """

        userid = self.request.user.id

        """
        Ещё несколько тонкостей:
            * Пример SQL запроса который получается через ORM: см. django_orm_sql_example.sql
            * Пример, как можно было сделать на сыром SQL (фактически по смыслу так же): см. raw_sql_example.sql
            * В реальном проекте хорошо бы "двигать" time border подписки по мере прочтения постов, а не только
                фильтровать по mark as read, потому что иначе таблица mark_as_read будет пухнуть. Нужно её
                периодчески чистить
            * ORM генерит ещё пару избыточных запросов. В реальном проекте возник бы вопрос атомарности
                - что если между этими запросами кто-то запишет данные?
        """

        res = models.Post.objects.prefetch_related(
            'user__suserto'
        ).filter(
            user__suserto__user_from_id=userid, user__suserto__datetime__lte=F('datetime')
        ).exclude(
            id__in=models.MyUser.read_posts.through.objects.filter(myuser=userid).values('post_id')
        ).order_by('-datetime')

        return res
