
# Maven
## Meta
* Это система управления сборкой и зависимостями для java аналогично make для C/C++
* В корне проекта лежат метафайлы, описывающие проект
* Утилита называется ``mvn``, и используется:
    * Либо из консоли в корне проекта ``mvn <команда>``, подробности ниже
    * Либо из IDE

## Теория
* Чтобы исходный код java превратился в файлы, готовые к выполнению в проде java-машиной, нужно сделать несколько последовательных стадий:
    * Проверка метаинфы проекта и зависимостей. Если чего не хватает по зависимостям - скачать (validate)
    * Компиляция (compile)
    * Юнит-тесты (test)
    * Упаковка в готовые файлы (package)
    * Интеграционные тесты (integration-test)
    * ... далее стадии про деплой, но пока не важно
* В терминах maven эти стадии называются **жизненным циклом проекта**
* Мы можем вызывать mvn для каждой стадии жизненного цикла, например ``mvn compile``
* Основной смысл - каждая следующая стадия требует выполнения предыдущей, т.е. вызывая ``mvn compile`` автоматически будут выполнены все стадии до compile

## Артефакты
* Понятие **артефакт** - это любая библиотека - что-то, что можно собрать и положить в репозиторий (например в виде jar)
* У артефакта есть понятие координаты - это однозначный идентификатор, по которому его можно найти в репозитории. Состоит из 3 строк - groupId, artifactId, version
* Все штуки, которые подключаются снаружи (не только библиотечные зависимости, но и всякие плагины для сборки и проч, подробнее ниже) - это артефакты

## Метафайл проекта
* Основной файл с дефалтовым называнием - ``pom.xml``. Есть ещё другие, их пока не рассматриваем
* Ниже пример pom.xml. Что здесь важно:
    * координаты артефакта
    * зависимости
    * настройки сборки(секция build)
```xml
<!-- Стандартная шапка, можно сразу смотреть ниже -->
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <!-- Координаты артефакта, который будет собран в этом проекте (т.е. они его однозначно идентифицируют в репозиториях) -->
  <groupId>org.baggins.javahw</groupId>
  <artifactId>maventest</artifactId>
  <version>1.0-SNAPSHOT</version>

  <!-- Как видно зависимости указываются в формате координат артефакта-->
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>

      <!-- Это не разбирался, но скорее всего стадия, для которой эта зависимость актуальна-->
      <scope>test</scope>
    </dependency>
  </dependencies>

  <!-- Сабж, погуглить, почитать -->
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>

  <!-- Об этой секции см. ниже -->
  <build>
    <pluginManagement>
      <plugins>
          <!-- Тут может быть много букв. Об этой секции см. ниже -->
      </plugins>
    </pluginManagement>
  </build>
</project>
```
* Почему здесь нет списка исходников? См. ниже в разделе архетипы

## Как работают зависимости
* На первой стадии стадии validate, maven всё что нужно скачает (можно добавить секцию repositories, но по умолчанию он знает стандартные репы)
* Есть локальный кэш на диске, у меня он общий в ``~/.m2/repository`` - создался сам при установке maven
* Зависимости скачиваются (как я понял по первому взгляду) в виде jar

## Настройка операций на стадиях и понятие плагинов
* В терминах maven плагин - это кусочек java-кода (библиотека), в котором прописано что надо делать для разных стадий. Упакован в jar.
* В каждом плагине есть понятие goal - если по-простому это типа функция внутри плагина
* В секции build можно прописать, что для таких-то стадий надо вызывать такие-то goal-ы из таких-то плагинов
* Разумеется, один плагин может содержать несколько goal-ов для разных стадий
* Там же в секции build прописывается какие вообще плагины надо подключать к проекту.
* Т.к. плагины - это тоже артефакты, подключаются они как и зависимости:
```
    <pluginManagement>
      <plugins>
        <plugin>
          <!-- разобраться, почему нет groupId --> 
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.0</version>
        </plugin>
    ...
```
* Есть плагины по умолчанию, их явно подключать не обязательно
* Эти плагины по умолчанию для каждой стадии делают интуитивно понятные действия - для стадии компиляции компилируют java-файлы в class-файлы, для стадии сборки (package) собирают всё в jar и т.д.
* Про то как написать свой плагин и назначить вызов goal-а из него для определённой стадии - https://sysout.ru/maven-goals-i-phases/

## Архетипы
* maven умеет создавать структуру директорий проекта с нуля в соответствии в некоторым шаблоном, который называется архетипом
* Из консоли, например создать проект по шаблону webapp (веб-приложение): ``mvn archetype:create -DgroupId=com.mycompany.app -DartifactId=my-webapp -DarchetypeArtifactId=maven-archetype-webapp`` 
* Судя по названию параметра ``DarchetypeArtifactId`` - архетип это тоже получается артефакт, т.е. лежит в репозиториях аналогично библиотекам
* Из IDEA тоже можно
* Архетипов много, основные здесь https://maven.apache.org/guides/introduction/introduction-to-archetypes.html

## Cтруктура директорий
* **Важно**: для maven нужна стандартная структура директорий. Для архетипа maven-archetype-quickstart например
```
./src
./src/main
./src/main/java
./src/main/java/org
./src/main/java/org/baggins
./src/main/java/org/baggins/javahw
./src/main/java/org/baggins/javahw/App.java
./src/main/java/org/baggins/javahw/file2.java
./src/test
./src/test/java
./src/test/java/org
./src/test/java/org/baggins
./src/test/java/org/baggins/javahw
./src/test/java/org/baggins/javahw/AppTest.java
./pom.xml
./maventest.iml
```
* По этой структуре директорий maven понимает какие есть исходники и какие тесты, т.е. файлы с кодом в pom (как это делается в С++) не добавляются
* TODO уточнить - для других архетипов может быть другая структура директорий и как тогда это прописать в pom? 

## Ещё немного про стадии
* Есть стадия ``clean``, она отдельная, т.е. её выполнение не требуется для других стадий
* Все основные стадии, подробнее https://habr.com/en/post/77333/
    * compile — компилирует исходники
    * test — прогоняет тесты классов из предыдущего шага
    * package — упаковывает скомпилированые классы в удобноперемещаемый формат (jar или war, к примеру)
    * integration-test — отправляет упаковынные классы в среду интеграционного тестирования и прогоняет тесты
    * verify — проверяет корректность пакета и удовлетворение требованиям качества
    * install — загоняет пакет в локальный репозиторий, откуда он (пекат) будет доступен для использования как зависимость в других проектах
    * deploy — отправляет пакет на удаленный production сервер, откуда другие разработчики его могут получить и использовать
* Для кастомных стадий типа deploy, по умолчанию действия конечно же нет. Чтобы её настроить как я понял и нужно написать свой плагин.
