# Основы java
## Простые типы
* Простые типы:
    * byte, знаковый
    * char - **2 байта, т.е. unicode-16**, беззнаковый
    * short - 2 байта, знаковый
    * int - 4 байта, знаковый	
    * long - 8 байт, знаковый	
    * float - 4 байт
    * double - 8 байт
    * boolean - 4 байт (потому что физически хранится как int)
* Типы сделаны так, чтобы обеспечить максимальную переносимость
* Особенности:
    * boolean в массивах - 1 байт
    * float, double могут иметь значения +- бесконечность и NaN
    * Вокруг стандартных типов есть объекты-обёртки c большой буквы: ``Integer``, ``Boolean`` и т.д. - чтобы передавать их по ссылкам и для рефлексии
    
## Объекты и указатели
* Всё остальное - объекты
* ``TSomeClass a = new TSomeClass();`` a - по смыслу указатель
* Приведение типов указателей можно только внутри иерархии классов
* Работы с сырыми адресами как в C++ нет
* Копировать (**поверхностная** копия) - метод clone(), класс должен реализовать интерфейс Cloneable
* Deepcopy из коробки нет, надо переопределять clone и делать руками

## Массивы
* Всё тривиально: ``int[] nums = {1,2,3};``
* Размер массива, как и в C++ фиксирован
* Технически массивы - это объекты, поэтому у них есть все методы от Object, и их можно передавать ссылками на Object. 
* Но они на уровне JVM работают по-особому
    
## Сравнение объектов и чисел
* **ОЧЕНЬ ВАЖНО** - не сравнивать строки и вообще объекты через ``==``, потому что это сравнение ссылок. Надо equals. Пример выстрела в ногу
```java
import java.util.Date;

public class HelloWorld {
    public static void main(String[] args) {
      ExampleDoNotCompareStringsWithEqEq();
      ExampleLiteralsOptimization();
    }
    
    public static void ExampleDoNotCompareStringsWithEqEq() { 
      // Строки и вообще объекты в общем случае НЕЛЬЗЯ сравнивать через ==
      System.out.println("ExampleDoNotCompareStringsWithEqEq"); 
      
      String s1 = "hello";
      String s2 = "hel";
      s2 += "lo";
      System.out.println(s1 == s2);  // false!
      System.out.println(s1.equals(s2));  // а вот так правильно - true
    }
    
    public static void ExampleLiteralsOptimization() { 
      // corner case - оптимизация компилятора в случае одинаковых литералов
      System.out.println("ExampleLiteralsOptimization"); 
      
      String s1 = "hello";
      String s2 = "hello";
      System.out.println(s1 == s2);  // true, потому что физически один объект создаётся
      
      s2 = "new";  // в случае изменения объектов становится 2, т.е. компилятор всё понимает, здесь сюрпризов нет
      System.out.println(s1);  // hello
      System.out.println(s2);  // new
      System.out.println(s1 == s2); //false
    }
}
```
* Для вещественных чисел как обычно == тоже не использовать, т. к. точность
* NaN не равно самому себе
* Разумеется equals можно переопределить, так же как и метод hashCode
    
## Классы, поля, методы
* В java нет отдельных функций, всё внутри классов
* Пример класса
```java
public class Box {
    private int width; 
    private static int someStaticMember = 42;  //значение static только для класса, не для объекта
    private final int someConstValue;  //final - это const в терминах C++ - инициализируется либо здесь, либо в конструкторе, далее неизменяемо
	
    Box(int a) { // Конструктор
        width = a;
        someConstValue = 44;
    }
    
    Box(Box other) { // Конструктор копирования
        width = other.a;
        someConstValue = other.someConstValue;
    }

    public int getVolume() {
    	return width * 10;
    }
    
    public static void staticMethod (){ //метод только для класса
       //
    }
    
    public final int finalMethod() { // не может быть переопределён при наследовании
        //
    }
}
```
* Модификаторы доступа полей и методов:
    * **private** - достпен только текущему классу (т.е. не доступен в т.ч. в наследниках)
    * **отсутствие модификатора** - private + доступ из текущего пакета
    * **protected** - private + доступ из текущего пакета и наследников (даже если наследник в другом пакете) пакета
    * **public** - доступен наружу всем
    
* Модификаторы доступа классов:
    * **private** - доступен только текущему пакету
    * **отсутствие модификатора** - то же самое (уточнить)
    * **protected** - то же самое (уточнить)
    * **public** - доступен из других пакетов

* Полностью статические классы:
    * Иногда делают конструктор private и только static методы - такой объект нельзя создать через new, это просто склад методов
    * Статический импорт - ``import static java.lang.Math.*;`` - тогда все статические методы класса можно использовать как обычные функции без названия этого класса
    
* Разное:
    * Класс можно объявить final - значит нельзя наследоваться
    * Если переменная final инициализирована так, что её можно посчитать на этапе компиляции, то её можно использовать для условной компиляции (см в другом разделе что это такое)
    * Перегрузка операторов как в C++ и в питоне, в java не поддерживается

## Наследование
* ``class Derived extends Base {...}``
* К методам базового класса можно через ``super.``
* Когда переопределяем метод, модификатор доступа у него должен быть не ниже чем у исходного
* В терминах C++ все методы классов по умолчанию виртуальные (т.е. ведут себя в режиме полиморфизма)
* Множественного наследования классов нет (интерфейсов есть - см ниже)
* Иногда перед переопределённым методом ставят аннотацию ``@override``, но это необязательно

## Интерфейсы
* Абстрактный метод можно пометить словом ``abstract``. Это метод без реализации, который реализовать в наследниках
* Если при объявлении класса вместо class написать interface, тогда все методы по умолчанию будут абстрактными 
* Далее наследуемся от интерфейса через слово implements: ``public class MyClass implements ExampleInterface``
* Зачем разделение на классы и интерфейсы? Потому что множественного наследования в java нет, а множественные implements интерфейсов - есть.
* В интерфейсе могут быть поля, но все они по умолчанию ``public static final``
* В Java есть интерфейсы, которые не содержат методов для реализации, а специальным образом обрабатываются JVM: Cloneable, Serializable, RandomAccess, Remote (выглядит как костыль...)

## Рефлексия
* Проверка принадлежности к классу ``if (foo instanceof Foo) {...}``, для наследников тоже работает
* Функция ``getClass`` , определённая для всех объектов, выдаёт объект типа ``Class<?>``, это как ``type`` в python
* Его же возвращает статическое поле class всех классов
* Проверка наследования для объектов типа class : ``Foo.class.isAssignableFrom(Bar.class)``

## Приведение типов
* Если приведение тривиально (например из short в int или объект из Derived в Base), тогда всё само работает: ``short a; long b = a;`` и ``Base foo = new Derived(...);`` 
* В остальных случаях можно в сишном стиле ``a = (short) b;``  и ``Derived foo = (Derived) base;``
* Если такой ручной каст невозможнен, будет либо ошибка компиляции, либо в рантайме исключение ``ClassCastException``
* Есть ещё у класса ``Class<?>`` метод ``cast()`` - скастить в себя. Проверяется только в runtime. Если что не так - либо вернёт null, либо исключение 

## Анонимные классы
* Можно сделать анонимный класс без имени внутри кода функции, который либо реализует другой класс, либо наследует интерфейс:
```java
interface SayHello {
    void say();
}

//какой-то метод
{
    //здесь создаётся не интерфейс (это нельзя), а его наследник
    static SayHello h = new SayHello() {
        @Override
        public void say() {
            System.out.println("Метод внутреннего анонимного класса");
        }
    };
}

```

## Лябмда-выражения
* Т.к. функций отдельных в java нет, то здесь всё несколько сложнее чем в питоне и C++
* Если нужно сохранить лямбда-функцию в какой-то переменной, это по сути будет небольшой объект класса с единственной функцией
* Поэтому надо интерфейс с одной функцией
```
@FunctionalInterface
interface MyInterface {
    // здесь определяется сигнатура лябмда выражения
    String reverse(String n);
}
```
* Дальше создаём объект лямбда-выражения - это физически будет класс, унаследованный от этого интерфейса
```java
MyInterface lam = (str) -> { ...; return ...}
...
String x = lam.reverse(...);
```
* Заметим, что str здесь объявляется без типа.
* Чаще всего эти функциональные интерфейсы есть в стандартных библиотеках
* Однострочные лямбды можно без скобок:  ``ref = (x) -> x * 3.1415;``
* Захват: все переменные по-умолчанию захватываются, но использовать можно только неизменяемые переменные, потому что не thread-safe
* Т.к. лямбда-выражение порождает объект определённого интерфейса их можно передавать в функции типа ``repeatIt(10, () -> System.out.println("aaa"))``

## Аннотации
* Перед любой сущностью в java (класс, метод, поле, пакет и т.д.) можно поставить аннотацию, которая похожа на декоратор в питоне: ``@SomeAnotation(field1=..., field2=...)``
* По смыслу это приклеить метаданные к сущности, которые потом можно получить на стадии рантайма или компиляции и на их основе сделать разное поведение как в рантайме, так и при компиляции.
* Таким образом через аннотации можно сделать нечто похожее на декоратор, но всё же это не декоратор
* Пример как сделать свою аннотацию
```java
import java.lang.annotation.*;

public class Main {
    public static void main(String[] args) {
        Animal cat = new Cat();
        Animal dog = new Dog();
        
        cat.printAnnotation();
        dog.printAnnotation();
    }
}

// Так объявляется своя аннотация и поля для неё. Как видно, аннотацию можно аннотировать другими аннотациями. 
// В данном примере мы говорим Target TYPE - значит наша аннотация будет применима только к классам,
// и Retention RUNTIME - значит надо сохранять её данные в рантайме
@Target(value=ElementType.TYPE)
@Retention(value= RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String field1();
    int field2() default 42;
}

// Базовый класс получает данные аннотации и выводит их на консоль
public class Animal {
    public void printAnnotation() {
        var anno = this.getClass().getAnnotation(MyAnnotation.class);
        System.out.println(String.format("annotations of %s:", this.getClass()));
        System.out.println(String.format("annotation field1 = %s", anno.field1()));
        System.out.println(String.format("annotation field2 = %d\n", anno.field2()));
    }
}

// классы-наследники с применением нашей аннотации
@MyAnnotation(field1="cat")
public class Cat extends Animal {}

@MyAnnotation(field1="dog", field2=11)
public class Dog extends Animal {}
```
* Есть встроенные стандартные аннотации для настройки компиляции, например @Override - предохраняет от опечаток в наследовании метода. Подробнее см. википедию.

## Сборка мусора - с точки зрения разработчика-пользователя
* Общий смысл интуитивно понятен - руками объекты не удаляем, всё само
* Есть метод finalize, его можно переопределить, он будет вызван ровно один раз когда объект будет почищен
* Если finalize зависнет, сборщик мусора не умрёт, т.к. вызывается через отдельную очередь
* В общем случае не гарантируется, что мусор будет уничтожен быстро. В некоторых случаях сборщик вызывается только когда кончилась память, отведённая процессу (уточнить - кстати как определяется это количество памяти?)
* Уточнить - это значит что java страдает обжорством памяти?
* Сборщик мусора можно дёрнуть явно: ``System.gc()``
* Можно настраивать разные режимы и есть тулзы для проверки как он работает, подробнее https://habr.com/ru/post/269621/
* Уточнить: сборщик мусора и очередь finalize работает в отдельном потоке?
* Если нужно как ``with`` в питоне или как деструктор в C++, т.е. освобождение ресурсов по выходу из скоупа, есть try с ресурами - см. про это в разделе исключения.

## Сборка мусора - немного под капотом
* Разные JVM могут по разному её реализовать
* Далее речь пойдёт про HotSpot
* Принцип работы на основе гипотезы - чем дольше живёт объект, тем менее вероятно он окажется мусором
* Поэтому объекты разделяются на 2 типа - молодые и старые.
* По какому-то критерию молодые переходят в старые, уточнить
* Есть два отдельных сборщика мусора - только для молодых и полный для всех. Молодой запускается чаще.
* Как определяется нужность объекта:
	* Не только по количеству ссылок, ведь друг на друга могут ссылаться ненужные объекты
	* Исходим из того, что связь объектов - это граф
	* Тогда в нём есть некоторые root-узлы. Всё, что недоступно из root-узлов - мусор
	* Для полного сборщика мусора рут-объекты - это всё статическое (уточнить что именно)
	* Для сборщика молодого мусора к рутам добавляем все старые объекты
	
## Про слово var
* В java 10 появилось нечто похожее на auto в C++: ``var x = SomeClass();``
* Однако оно работает далеко не везде, там 100500 ограничений, чтобы предотвратить ошибки про путаницу в типах
* TODO описать подробнее
