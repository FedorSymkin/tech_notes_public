# Gradle

## Meta
* Сначала желательно прочитать коротко про [maven](maven.md)
* Gradle - система сборки для java, более современная, чем maven (и, честно говоря, более мозговыносящая...)
* Общий принцип использования такой же: метафайл проекта ``build.gradle`` и вызов утилиты gradle с командами (или вызов gradle из IDE)
* Файлы gradle, если смотреть с нуля, выглядят как адовое нагромождение конфиго-переконфигов, но если понять общую инфраструктуру, всё встаёт на свои места

## Теория
* Файлы gradle - это не декларативные конфиги, как в maven, а куски кода на языке groovy (надмножество java)
* То, что в maven называлось стадиями (т.е. скомилить, собрать, протестить и т.д.), в gradle называется **тасками**. Это важно, см ниже
* В maven граф зависимостей операций друг от друга был просто линейной цепочкой, которую нельзя было менять. В gradle граф зависимостей тасков определяется самим разработчиком
* А **стадии** в gradle имеют другой смысл, чем в maven - есть 3 глобальный стадии, которые для любого запуска gradle выполняются всегда последовательно:
    * **Инициализация** (TODO что тут происходит?)
    * **Конфигурирование** (подготовка объектов, в т.ч. составление графа зависимостей тасок)
    * **Выполнение** (выполнение тасок в соответствии с графом зависимостей)

## Общая инфраструктура gradle
* Пока без привязки к конкретным таскам, а в целом как читать файлы gradle
* Общий вид (глубоко пока не вникать, всё станет понятно ниже):
```groovy
repositories {
    jcenter()
}

dependencies {
    compile 'com.google.guava:guava:23.0'
    testCompile 'junit:junit:4.12'
}

task hello

hello.doLast {
    println 'hello'
}
```
* Ключевой тезис - hello, repositories, dependencies в этом примере - это технически объекты java, которые создаются и настраиваются на стадии **конфигурирования**.
* Поэтому работу с gradle можно воспринимать как написание кода какой-то выполнялки, где всё конфигурируется не конфигами, а полями разных объектов и вызовом их методов
* Всё, что находится внутри скобок - это код на groovy, работающий с этими объектами
* ``repositories {...}`` - выполнить этот код для объекта repositories сразу на стадии **конфигурирования**.
    * **ВАЖНО** - вроде как если два раза в разных местах написать `repositories {...}`` - код не заменится, а добавится, TODO проверить.
* ``task hello`` - cоздаётся объект hello класса org.gradle.api.DefaultTask_Decorated
* ``hello.doLast {...}`` - у таска есть список callable, которые надо последовательно выполнить, когда дойдём до этой таски в графе на стадии **выполнения**. Т.е. добавляем новый callable в конец списка. Само это добавления опять же происходит на стадии **конфигиурирования**
* Сахар - можно встретить что-то типа ``hello << {...}`` - это doLast и даже ``task hello << {...}`` - это создать таску и сразу toLast. Однако ``<<`` - deprecated
* Обобщая: сам по себе файл gradle в целом - тоже код на groovy, который выполняется на стадии **конфигурирования**, поэтому можно написать ``println 'hello'`` просто так вне блока.

## Простейший запуск gradle для примера выше
* В директории где build.gradle: ``gradle hello``, где hello - имя таски, которая будет точкой входа в графе

## Подробнее про синтаксис
* Примеры как ещё можно вызвать метод объекта:
```groovy
// по сути это как this.doLast. Но слово this здесь не работает!
hello {
    doLast { println "aaa" }
}

// А это тоже вызов метода plugins.id(String). Можно и со скобками
plugins {
    id "com.gradle.build-scan"
}

// эквивалентно plugins.id("com.gradle.build-scan").version("3.1.1")
plugins {
    id "com.gradle.build-scan" version "3.1.1"
}
```
* Пример вызова любого кастомного кода как на groovy, так и на чистой java
```groovy
void printAllMethods( obj ){
    if( !obj ){
		println( "Object is null\r\n" );
		return;
    }
	if( !obj.metaClass && obj.getClass() ){
        printAllMethods( obj.getClass() );
		return;
    }
	def str = "class ${obj.getClass().name} functions:\r\n";
	obj.metaClass.methods.name.unique().each{ 
		str += it+"(); "; 
	}
	println "${str}\r\n";
}

void pureJavaCode(String s) {
    System.out.println("hello from pure java: " + s);
}

task hello

hello {
    printAllMethods(hello);
    pureJavaCode("world");
}
```

## Плагины - откуда берётся код для стандартных тасок сборки
* Как в и maven-е, в файл gradle подключаются плагины - куски кода из репозиториев (тоже jar?)
* Плагины добавляют разные готовые объекты - таски и прочее (готовые - т.е. например таски с уже каким-то кодом, выполняющим стандартные действия)
* В дефалтовых тасках из станадртных плагинов собственно и живёт код по стандартным действиям - компиляция, сборка и т.д.
* Там же, в стандартных плагинах настроен граф зависимостей тасок
* Примеры подключения стандартного плагина
```groovy
// в объекте plugins на стадии конфигурирования вызываем метод id("java").
plugins {
    id 'java'
}

// более расширенный пример:
// plugins.id('org.gradle.test-retry').version('1.1.1').apply(false)
// apply false - это скачать чтоб было, но не применять сюда
plugins {
    id 'org.gradle.test-retry' version '1.1.1' apply false
}

// ещё можно так, но пишут, что это deprecated
apply plugin: 'java'


```

## Работа с тасками и графом зависимостей тасок
* Зависимость тасок: просто вызов метода ``task1.dependsOn(task2)`` на стадии **конфигурирования**
* Расширение существующих тасок. Если плагин добавил например таску test, то в неё можно дописать либо доп. действия стадии конфигурирования: ``test {...}``, либо стадии выполнения: ``test.doLast {...}``
* А ещё есть doFirst - добавить действие в начало таски
* Т.е. если в файле gradle видим что-то вроде ``SomeUnknownWord {...}``, то это либо таска, которую добавил какой-то плагин, либо какой-то другой системный объект
* Чтобы понять какие таски понадобавляли: ``gradle tasks``. Вот кусок выхлопа для стандартного проекта
```
...
Application tasks
-----------------
run - Runs this project as a JVM application

Build tasks
-----------
assemble - Assembles the outputs of this project.
build - Assembles and tests this project.
buildDependents - Assembles and tests this project and all projects that depend on it.
buildNeeded - Assembles and tests this project and all projects it depends on.
classes - Assembles main classes.
clean - Deletes the build directory.
jar - Assembles a jar archive containing the main classes.
testClasses - Assembles test classes.
...
```
* Это и есть точки входа, за которые надо дёргать gradle в случае стандартных плагинов, например ``gradle build``
* Кстати, tasks - это тоже таска, которая по умолчанию добавляется. В этом же выхлопе можно посмотреть список таких служебных точек входа

## Типовые таски из коробки, которые можно включить в граф
* Пример
```groovy
//Наследуемся от стандартной таски Copy (копировать файл)
task myCopyFiles(type: Copy) {
    // Настраивем что куда копировать путём вызова методов from, into, include из класса Copy
    from 'resources'
    into 'target'
    include '**/*.xml', '**/*.txt', '**/*.properties'
}
```
* Включаем в граф: ``someTask.dependsOn(myCopyFiles)``
* Ещё 100500 типовых тасок - google it

## Зависимости модулей
* Основной тезис: зависимости разделяются на группы, которые называются **конфигурациями** зависимостей.
* Пример таких групп:
    * compile - зависимости для компиляции основного кода
    * testCompile - зависимости для компиляции тестов
    * runtime - зависимости для работы в проде
    * и т.д.
* Пример зависимости для разных групп
```groovy
dependencies {
    compile 'com.google.guava:guava:23.0'  //строка в кавычках выглядит так же, как координаты артефакта в maven, похоже это они и есть
    testCompile 'junit:junit:4.12'

    // Упячка: формально выглядит как вызов методов объекта dependencies.compile(...), но таких методов для объекта dependencies нет, какая-то магия
}
```
* Откуда берутся группы? Их создаёт плагин, т.е. compile, testCompile и т.д. - их сделал стандартный плагин java. Как сделал - пока не важно (вызвал какой-то метод какого-то системного объекта)
* TODO: как посмотреть доступные группы зависимостей?
* Как используются группы: быстро детально разобраться не получилось, поэтому интуитивно на основе экспериментов:
    * Скачивание зависимостей происходит не толпой в начале, а в процессе разных тасок уже на стадии **выполнения**
    * Конкретная таска может сказать "скачать зависимости такой-то группы", как это сделать пока не разбирался
    * Таким образом, если делаем например ``gradle clean`` ничего не скачивается, потому что по графу не доходим до тасок, которые хотят зависимостей
* Зависимости можно указать не только от артефактов в репозитории:
    * ``compile project(:some_name)`` - от дочернего проекта в поддиректории
    * ``compile file(:some_path)``


## Репозитории
* Тут всё просто - вызываем методы системного объекта repositories на стадии **конфигурирования**
```groovy
repositories {
    // захардкоженные стандартные ?
    mavenCentral() // maven - это просто название репы, утилита maven тут не при чём
    jcenter()

    // Кастомный
    maven {  // а здесь типа вызывается метод maven, которому передаётся объект с полем url? Т.е. добавить репу с интерфейсом как у maven?
        url "http://repo2.mycompany.com/maven2"
    }
}
```

## Подпроекты
* Можно сделать вложенные директории с build.gradle, чтобы всё каскадно собиралось
* Добавляем файл settings.gradle
```
rootProject.name = 'test_gradle'
include 'sub'
```
* В некоторых случаях добавляем зависимость от подпроекта: dependencies {
    compile project(':sub')
}
* **ОЧЕНЬ ВАЖНОЕ TODO** - что-то я сходу не пойму какой эффект от добавления подпроекта в dependencies. При добавлении в settings.gradle таска, вызванная в root-проекте, выполняется в sub-проекте в любом случае.
 
## gradlew
* Выше была речь про служебные точки входа (таски)
* Так вот есть полезная таска wrapper - она генерит скрипт gradlew (и gradlew.bat)
* Этот скрипт можно использовать для разворачивания локального gradle с нуля голой машине без java-тулинга (просто запустить gradlew и сам всё скачает)
* Далее gradlew можно использовать так же как gradle

## Разные другие фичи
* Объект buildscript - это похоже глобальный объект с общими настройками
* Выражение ``apply from`` - это кажется include одного gradle файла в другой
* Ещё полезные фичи тасок
      * метод onlyIf {...} - условное выполнение
      * метод didWork - узнать отработала ли таска
      * метод enabled - отключить
* Создать проект с нуля по шаблону например java-application: ``gradle init --type java-application``. java-application - это тоже плагин, короче тут вроде как в maven

## Погрузиться подробнее, помимо официальных доков
* https://habr.com/ru/post/167227/
* https://habr.com/ru/post/458046/
* https://habr.com/ru/company/redmadrobot/blog/275515/
* https://javarush.ru/groups/posts/2126-kratkoe-znakomstvo-s-gradle
